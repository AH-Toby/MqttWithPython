# 心跳机制

对于MQTT服务器来说，它要判断一台MQTT客户端是否依然保持连接可以检查这台客户端是不是经常发送消息给服务端。如果经常收到客户端的消息，那么没问题，这个客户端肯定在线。

但是有些客户端并不经常发送消息给服务端。对于这种客户端，服务端可以使用类似心跳检测的方法，来判断客户端是否在线。不过客户端设备没有心脏，自然不会跳动。可是我们可以为它们配上一个类似心脏的机制，这个心脏机制就是让客户端在没有向服务端发送信息时，可以定时向服务端发送一条消息。这条用于心跳机制的消息也被称作心跳请求（PINGREQ）。心跳请求的作用正是用于告知服务端，当前客户端依然在线。服务端在收到客户端的心跳请求后，会回复一条消息。这条回复消息被称作心跳响应（PINGRESP）。

![MQTT心跳机制](https://raw.githubusercontent.com/AH-Toby/ImageStorage/master/ImageStorageMQTT-Keep-Alive-1.jpg)

由于心跳请求是客户端定时发送的，一旦服务端发现客户端停止发送请求信息，那么服务端就会知道，这台客户端已经断开了连接。

这个心跳机制不仅可以用于服务端判断客户端是否保持连接，也可以用于客户端判断自己与服务端是否保持连接。如果客户端在发送心跳请求（PINGREQ）后，没有收到服务端的心跳响应（PINGRESP），那么客户端就会认为自己与服务端的连接已经被断开了。

以上是心跳机制(Keep Alive)的简单介绍，为了更深入的了解心跳机制，我们接下来回忆一下MQTT客户端在连接服务端的过程。请见下表，客户端连接服务端时会像服务端发送CONNECT报文

| 报文字段         | 解释             | 示例              | 是否必填 | 注意事项                 |
| ---------------- | ---------------- | ----------------- | -------- | ------------------------ |
| clientId         | 客户端ID         | "client-1"        | 必填     | 必须唯一                 |
| cleanSession     | 清除会话         | false             | 必填     | 默认为true               |
| username         | 用户名称         | "toby"            | 非必填   | 服务端鉴权用             |
| password         | 用户密码         | "123"             | 非必填   | 服务端鉴权用             |
| lastWillTopic    | 遗嘱主题         | "/hans/will"      | 非必填   | 异常断线使用             |
| lastWillQos      | 遗嘱服务质量等级 | 2                 | 非必填   | 异常断线使用只有0,1,2    |
| lastWillMessage  | 遗嘱消息         | "unexpected exit" | 非必填   | 异常断线使用             |
| lastWillRetain   | 遗嘱保留         | fase              | 非必填   | 默认为false,异常断线使用 |
| <u>keepAlive</u> | 心跳时间间隔     | <u>60</u>         | 必填     | 数字类型                 |

我刚刚给大家讲过，在心跳机制中，客户端要定时向服务端发送心跳请求(PINGREQ)报文。那么客户端发送心跳请求的时间间隔是多少呢？

这个心跳时间间隔是我们在开发客户端时进行设置的。我们在编写控制程序时，会在程序中对心跳时间间隔进行设置。

设置好心跳时间间隔后，客户端就知道多久要发送一条心跳请求给服务端。但是这里存在一个问题。光是客户端知道心跳时间间隔还不够，服务端也需要知道客户端的心跳时间间隔，这样服务端才能定时检查客户端的心跳请求消息。

因此，在客户端连接服务端时，会将心跳时间间隔信息放入CONNECT报文。也就是上表中最后一行的信息keepAlive。这个keepAlive正是用于告知服务端心跳时间间隔的。

以上示例表中我们看到keepAlive数值为60。这就意味着，客户端的心跳间隔时间是60秒。

**假如客户端的心跳间隔时间是60秒，那么服务端是不是每隔60秒就检查一次客户端是否发来心跳请求呢？**

如果客户端在心跳时间间隔内发布了消息给服务端，那么服务端不需要客户端发送心跳请求也可以确定该客户端肯定在线。

![MQTT心跳机制](https://raw.githubusercontent.com/AH-Toby/ImageStorage/master/ImageStorageMQTT%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6.jpg)

但是当客户端在心跳间隔内没有发布消息给服务端，这时客户端会主动发送一个心跳请求消息给服务端。以表明自己仍让在线

![MQT心跳机制](https://raw.githubusercontent.com/AH-Toby/ImageStorage/master/ImageStorageMQT%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6.jpg)

简而言之，客户端在心跳间隔时间内，如果有消息发布，那就直接发布消息而不发布心跳请求，但是在心跳间隔时间内，客户端没有消息发布，那么它就会发布一条心跳请求给服务端，这个心跳请求的目的就是为了告诉服务端，我还在线，你放心吧。

另外，在实际运行中，如果服务端没有在1.5倍心跳时间间隔内收到客户端发布消息(PUBLISH)或发来心跳请求(PINGREQ)，那么服务端就会认为这个客户端已经掉线。

举例来说，如果心跳时间间隔是60秒。那么服务端在90秒内没有收到客户端发布的消息也没有收到PINGREQ请求，那么它就会认为客户端已经掉线。

另外，心跳机制不仅仅用于服务端判断客户端是否在线。客户端也可以利用这一机制来判断自己是否与服务端仍保持连接。如果客户端发送了心跳请求(PINGREQ)给服务端一段时间后，仍然没有收到服务端回复的心跳确认。那么客户端也会认为自己已经断开了与服务端的连接。

